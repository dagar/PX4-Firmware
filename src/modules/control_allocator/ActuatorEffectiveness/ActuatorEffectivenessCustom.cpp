/****************************************************************************
 *
 *   Copyright (c) 2021 PX4 Development Team. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name PX4 nor the names of its contributors may be
 *    used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 ****************************************************************************/

#include "ActuatorEffectivenessCustom.hpp"

ActuatorEffectivenessCustom::ActuatorEffectivenessCustom(ModuleParams *parent):
	ModuleParams(parent)
{
}

float getScaleParameter(uint8_t n)
{
	// CA_ACTn_SC: scale
	char buffer[17];
	sprintf(buffer, "CA_ACT%u_SC", n);
	param_t param_handle = param_find(buffer);

	if (param_handle == PARAM_INVALID) {
		PX4_ERR("invalid parameter %s", buffer);
		return 0.f;
	}

	float scale = 1.f;

	if (param_get(param_handle, &scale) != PX4_OK) {
		PX4_ERR("param_get %s failed", buffer);
		return scale;
	}

	return 0.f;
}

bool ActuatorEffectivenessCustom::getEffectivenessMatrix(matrix::Matrix<float, NUM_AXES, NUM_ACTUATORS> &matrix,
		bool force)
{
	// TODO:
	//  - airspeed scaling
	//  - battery scaling
	//  - publish motors and servos (handle ranges)
	//  - disable individual actuators
	//      - feedback from output module (actual failures)
	//      - VTOL transitions (cleanly blend in and out?)
	//      -   eg disable all downward thrust
	//      -   eg disable all control surfaces
	//      -  blend in/out higher level by adjusting max? then completely purge from effectiveness once off
	if (_updated || force) {
		_updated = false;

		int num_actuators = 0;
		_effectiveness.zero();

		for (int n = 0; n < NUM_ACTUATORS; n++) {
			// CA_ACTn_FUNC: look up function
			char buffer[17];
			sprintf(buffer, "CA_ACT%u_FUNC", n);
			int32_t ctrl_func = 0;
			param_get(param_find(buffer), &ctrl_func);

			switch (ctrl_func) {
			case 0:
				// disabled
				break;

			case 1: {
					// 1: custom thrust (parameters)
					matrix::Vector3f axis{};
					matrix::Vector3f position{};
					float thrust_coef = 0.f;
					float moment_ratio = 0.f;

					for (int i = 0; i < 3; i++) {
						char axis_char = 'X' + i;

						// CA_ACTn_P{X,Y,Z}
						sprintf(buffer, "CA_ACT%u_P%c", n, axis_char);

						if (param_get(param_find(buffer), &position(i)) != PX4_OK) {
							PX4_ERR("unable to get %s", buffer);
						}

						// CA_ACTn_A_{X,Y,Z}
						sprintf(buffer, "CA_ACT%u_A%c", n, axis_char);

						if (param_get(param_find(buffer), &axis(i)) != PX4_OK) {
							PX4_ERR("unable to get %s", buffer);
						}
					}

					// CA_ACTn_CT TODO
					sprintf(buffer, "CA_ACT%u_CT", n);
					param_get(param_find(buffer), &thrust_coef);

					// CA_ACTn_KM TODO
					sprintf(buffer, "CA_ACT%u_KM", n);
					param_get(param_find(buffer), &moment_ratio);

					// Normalize axis
					float axis_norm = axis.norm();

					if (axis_norm > FLT_EPSILON) {
						axis /= axis_norm;

					} else {
						// Bad axis definition, ignore this rotor
						continue;
					}

					// Get coefficients
					float ct = thrust_coef;
					float km = moment_ratio;

					if (fabsf(ct) < FLT_EPSILON) {
						continue;
					}

					// Compute thrust generated by this rotor
					const matrix::Vector3f thrust{ct * axis};

					// Compute moment generated by this rotor
					const matrix::Vector3f moment{ct * position.cross(axis) - ct *km * axis};

					// Fill corresponding items in effectiveness matrix
					for (size_t j = 0; j < 3; j++) {
						_effectiveness(j, n) = moment(j);
						_effectiveness(j + 3, n) = thrust(j);
					}
				}

				break;

			case 2: {
					// 2: custom torque (parameters)

					// CA_ACTn_TRQ_R
					// CA_ACTn_TRQ_P
					// CA_ACTn_TRQ_Y
					char torque_str[3][17];
					sprintf(torque_str[0], "CA_ACT%u_TRQ_R", n);
					sprintf(torque_str[1], "CA_ACT%u_TRQ_P", n);
					sprintf(torque_str[2], "CA_ACT%u_TRQ_Y", n);

					for (int i = 0; i < 3; i++) {
						// CA_ACTn_TRQ_{R,P,Y}
						param_get(param_find(torque_str[i]), &_effectiveness(i, n));
					}
				}
				break;

			case 100: {
					// 100: Aileron, scaled (CA_ACTn_SC) roll torque
					_effectiveness(0, n) = getScaleParameter(n);
				}
				break;

			case 101: {
					// 101: Elevator, scaled (CA_ACTn_SC) pitch torque
					_effectiveness(1, n) = getScaleParameter(n);
				}
				break;

			case 102: {
					// 102: Rudder, scaled (CA_ACTn_SC) yaw torque
					_effectiveness(2, n) = getScaleParameter(n);
				}
				break;

			case 103: {
					// 103: Throttle, scaled (CA_ACTn_SC) X thrust
					_effectiveness(4, n) = getScaleParameter(n);
				}
				break;

			case 104: {
					// 104: Elevon(+), scaled (CA_ACTn_SC) roll & pitch torque
					float scale = getScaleParameter(n);
					_effectiveness(0, n) = 0.5f * scale;
					_effectiveness(1, n) = 0.5f * scale;
				}
				break;

			case 105: {
					// 105: Elevon(+), scaled (CA_ACTn_SC) -roll & pitch torque
					float scale = getScaleParameter(n);
					_effectiveness(0, n) = -0.5f * scale;
					_effectiveness(1, n) =  0.5f * scale;
				}
				break;

			case 106: {
					// 106: V-Tail (+), scaled (CA_ACTn_SC) pitch & yaw torque
					float scale = getScaleParameter(n);
					_effectiveness(1, n) = 0.5f * scale;
					_effectiveness(2, n) = 0.5f * scale;
				}
				break;

			case 107: {
					// 107: V-Tail (-), scaled (CA_ACTn_SC) pitch & -yaw torque
					float scale = getScaleParameter(n);
					_effectiveness(1, n) =  0.5f * scale;
					_effectiveness(2, n) = -0.5f * scale;
				}
				break;

			default:
				PX4_ERR("%s invalid function %d", buffer, n);
				break;
			}

			if (_effectiveness.col(n).longerThan(0.f)) {
				num_actuators = n + 1;
			}
		}

		_effectiveness.transpose().print();

		_num_actuators = num_actuators;
		matrix = _effectiveness;
		return true;
	}

	return false;
}
