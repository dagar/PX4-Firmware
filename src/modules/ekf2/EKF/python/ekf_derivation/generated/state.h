// --------------------------------------------------
// This file was autogenerated, do NOT modify by hand
// --------------------------------------------------

#ifndef EKF_STATE_H
#define EKF_STATE_H

#include <matrix/math.hpp>

namespace estimator
{
struct StateSample {

	// using ekf_float_t = double;

	matrix::Quaternion<ekf_float_t> quat_nominal{};
	matrix::Vector3<ekf_float_t> vel{};
	matrix::Vector3<ekf_float_t> pos{};
	matrix::Vector3<ekf_float_t> gyro_bias{};
	matrix::Vector3<ekf_float_t> accel_bias{};
	matrix::Vector3<ekf_float_t> mag_I{};
	matrix::Vector3<ekf_float_t> mag_B{};
	matrix::Vector2<ekf_float_t> wind_vel{};

	matrix::Vector<ekf_float_t, 24> Data() const {
		matrix::Vector<ekf_float_t, 24> state;
		state.slice<4, 1>(0, 0) = quat_nominal;
		state.slice<3, 1>(4, 0) = vel;
		state.slice<3, 1>(7, 0) = pos;
		state.slice<3, 1>(10, 0) = gyro_bias;
		state.slice<3, 1>(13, 0) = accel_bias;
		state.slice<3, 1>(16, 0) = mag_I;
		state.slice<3, 1>(19, 0) = mag_B;
		state.slice<2, 1>(22, 0) = wind_vel;
		return state;
	};

	const matrix::Vector<ekf_float_t, 24>& vector() const {
		return *reinterpret_cast<matrix::Vector<ekf_float_t, 24>*>(const_cast<ekf_float_t*>(reinterpret_cast<const ekf_float_t*>(&quat_nominal)));
	};

};
static_assert(sizeof(matrix::Vector<ekf_float_t, 24>) == sizeof(StateSample), "state vector doesn't match StateSample size");

struct IdxDof { unsigned idx; unsigned dof; };
namespace State {
	static constexpr IdxDof quat_nominal{0, 3};
	static constexpr IdxDof vel{3, 3};
	static constexpr IdxDof pos{6, 3};
	static constexpr IdxDof gyro_bias{9, 3};
	static constexpr IdxDof accel_bias{12, 3};
	static constexpr IdxDof mag_I{15, 3};
	static constexpr IdxDof mag_B{18, 3};
	static constexpr IdxDof wind_vel{21, 2};
	static constexpr uint8_t size{23};
};
}
#endif // !EKF_STATE_H
